"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var querystring = __importStar(require("querystring"));
var debug_1 = __importDefault(require("debug"));
var raw_body_1 = __importDefault(require("raw-body"));
var crypto_1 = __importDefault(require("crypto"));
var tsscmp_1 = __importDefault(require("tsscmp"));
var errors_1 = require("./errors");
var util_1 = require("./util");
var debug = debug_1.default('@slack/interactive-messages:http-handler');
function createHTTPHandler(adapter) {
    var poweredBy = util_1.packageIdentifier();
    /**
     * Handles sending responses
     *
     * @param res - Response object
     * @returns Returns a function used to send response
     */
    function sendResponse(res) {
        return function (_a) {
            var status = _a.status, content = _a.content;
            res.statusCode = status;
            res.setHeader('X-Slack-Powered-By', poweredBy);
            if (typeof content === 'string') {
                res.end(content);
            }
            else if (!util_1.isFalsy(content)) {
                res.setHeader('Content-Type', 'application/json');
                res.end(JSON.stringify(content));
            }
            else {
                res.end();
            }
        };
    }
    /**
     * Parses raw bodies of requests
     *
     * @param body - Raw body of request
     * @returns Parsed body of the request
     */
    function parseBody(body) {
        var parsedBody = querystring.parse(body);
        if (!util_1.isFalsy(parsedBody.payload)) {
            return JSON.parse(parsedBody.payload);
        }
        return parsedBody;
    }
    /**
     * Method to verify signature of requests
     *
     * @param signingSecret - Signing secret used to verify request signature
     * @param requestHeaders - The signing headers. If `req` is an incoming request, then this should be `req.headers`.
     * @param body - Raw body string
     * @returns Indicates if request is verified
     */
    function verifyRequestSignature(signingSecret, requestHeaders, body) {
        // Request signature
        var signature = requestHeaders['x-slack-signature'];
        // Request timestamp
        var ts = parseInt(requestHeaders['x-slack-request-timestamp'], 10);
        // Divide current date to match Slack ts format
        // Subtract 5 minutes from current time
        var fiveMinutesAgo = Math.floor(Date.now() / 1000) - (60 * 5);
        if (ts < fiveMinutesAgo) {
            debug('request is older than 5 minutes');
            throw errors_1.errorWithCode(new Error('Slack request signing verification outdated'), errors_1.ErrorCode.RequestTimeFailure);
        }
        var hmac = crypto_1.default.createHmac('sha256', signingSecret);
        var _a = signature.split('='), version = _a[0], hash = _a[1];
        hmac.update(version + ":" + ts + ":" + body);
        if (!tsscmp_1.default(hash, hmac.digest('hex'))) {
            debug('request signature is not valid');
            throw errors_1.errorWithCode(new Error('Slack request signing verification failed'), errors_1.ErrorCode.SignatureVerificationFailure);
        }
        debug('request signing verification success');
        return true;
    }
    /**
     * Request listener used to handle Slack requests and send responses and
     * verify request signatures
     */
    return function (req, res) {
        debug('request received - method: %s, path: %s', req.method, req.url);
        // Function used to send response
        var respond = sendResponse(res);
        // If parser is being used and we don't receive the raw payload via `rawBody`,
        // we can't verify request signature
        if (!util_1.isFalsy(req.body) && util_1.isFalsy(req.rawBody)) {
            respond({
                status: 500,
                content: process.env.NODE_ENV === 'development'
                    ? 'Parsing request body prohibits request signature verification'
                    : undefined,
            });
            return;
        }
        // Some serverless cloud providers (e.g. Google Firebase Cloud Functions) might populate
        // the request with a bodyparser before it can be populated by the SDK.
        // To prevent throwing an error here, we check the `rawBody` field before parsing the request
        // through the `raw-body` module (see Issue #85 - https://github.com/slackapi/node-slack-events-api/issues/85)
        var parseRawBody;
        if (!util_1.isFalsy(req.rawBody)) {
            debug('Parsing request with a rawBody attribute');
            parseRawBody = Promise.resolve(req.rawBody);
        }
        else {
            debug('Parsing raw request');
            parseRawBody = raw_body_1.default(req);
        }
        parseRawBody
            .then(function (bodyBuf) {
            var rawBody = bodyBuf.toString();
            if (verifyRequestSignature(adapter.signingSecret, req.headers, rawBody)) {
                // Request signature is verified
                // Parse raw body
                var body = parseBody(rawBody);
                if (body.ssl_check) {
                    respond({ status: 200 });
                    return;
                }
                var dispatchResult = adapter.dispatch(body);
                if (dispatchResult !== undefined) {
                    // TODO: handle this after responding?
                    // tslint:disable-next-line no-floating-promises
                    dispatchResult.then(respond);
                }
                else {
                    // No callback was matched
                    debug('no callback was matched');
                    respond({ status: 404 });
                }
            }
        }).catch(function (error) {
            if (error.code === errors_1.ErrorCode.SignatureVerificationFailure || error.code === errors_1.ErrorCode.RequestTimeFailure) {
                respond({ status: 404 });
            }
            else if (process.env.NODE_ENV === 'development') {
                respond({ status: 500, content: error.message });
            }
            else {
                respond({ status: 500 });
            }
        });
    };
}
exports.createHTTPHandler = createHTTPHandler;
//# sourceMappingURL=http-handler.js.map