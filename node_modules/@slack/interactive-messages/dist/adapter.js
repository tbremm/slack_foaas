"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable import-name */
var http_1 = __importDefault(require("http"));
var axios_1 = __importDefault(require("axios"));
var lodash_isstring_1 = __importDefault(require("lodash.isstring"));
var lodash_isregexp_1 = __importDefault(require("lodash.isregexp"));
var lodash_isfunction_1 = __importDefault(require("lodash.isfunction"));
var lodash_isplainobject_1 = __importDefault(require("lodash.isplainobject"));
var debug_1 = __importDefault(require("debug"));
var errors_1 = require("./errors");
var http_handler_1 = require("./http-handler");
var util_1 = require("./util");
/* tslint:enable import-name */
var debug = debug_1.default('@slack/interactive-messages:adapter');
/**
 * Transforms various forms of matching constraints to a single standard object shape
 * @param matchingConstraints - the various forms of matching constraints accepted
 * @returns an object where each matching constraint is a property
 */
function formatMatchingConstraints(matchingConstraints) {
    if (matchingConstraints === undefined || matchingConstraints === null) {
        throw new TypeError('Constraints cannot be undefined or null');
    }
    var ret = {};
    if (!lodash_isplainobject_1.default(matchingConstraints)) {
        ret.callbackId = matchingConstraints;
    }
    else {
        ret = Object.assign({}, matchingConstraints);
    }
    return ret;
}
/**
 * Validates general properties of a matching constraints object
 * @param matchingConstraints - object describing the constraints on a callback
 * @returns `false` represents successful validation, an error represents failure and describes why validation failed.
 */
function validateConstraints(matchingConstraints) {
    if (!util_1.isFalsy(matchingConstraints.callbackId) &&
        !(lodash_isstring_1.default(matchingConstraints.callbackId) || lodash_isregexp_1.default(matchingConstraints.callbackId))) {
        return new TypeError('Callback ID must be a string or RegExp');
    }
    if (!hasBlockRelatedConstraints(matchingConstraints)) {
        return false;
    }
    if (!util_1.isFalsy(matchingConstraints.blockId) &&
        !(lodash_isstring_1.default(matchingConstraints.blockId) || lodash_isregexp_1.default(matchingConstraints.blockId))) {
        return new TypeError('Block ID must be a string or RegExp');
    }
    if (!util_1.isFalsy(matchingConstraints.actionId) &&
        !(lodash_isstring_1.default(matchingConstraints.actionId) || lodash_isregexp_1.default(matchingConstraints.actionId))) {
        return new TypeError('Action ID must be a string or RegExp');
    }
    return false;
}
/**
 * Validates properties of a matching constraints object specific to registering an options request
 * @param matchingConstraints - object describing the constraints on an options handler
 * @returns `false` represents successful validation, an error represents failure and describes why validation failed.
 */
function validateOptionsConstraints(optionsConstraints) {
    if (!util_1.isFalsy(optionsConstraints.within) &&
        !(optionsConstraints.within === 'interactive_message' ||
            optionsConstraints.within === 'block_actions' ||
            optionsConstraints.within === 'dialog')) {
        return new TypeError('Within must be \'block_actions\', \'interactive_message\' or \'dialog\'');
    }
    // We don't need to validate unfurl, we'll just coerce it to a boolean
    return false;
}
/**
 * Validates properties of a matching constraints object specific to registering a view submission or view closed
 * request
 * @param viewConstraints - object describing the constraints on a view submission or view closed handler
 * @returns `false` represents successful validation, an error represents failure and describes why validation failed.
 */
function validateViewConstraints(viewConstraints) {
    if (viewConstraints.externalId === null ||
        ((!util_1.isFalsy(viewConstraints.externalId) &&
            !(lodash_isstring_1.default(viewConstraints.externalId) || lodash_isregexp_1.default(viewConstraints.externalId))))) {
        return new TypeError('External ID must be a string or RegExp');
    }
    if (viewConstraints.viewId === null ||
        (!util_1.isFalsy(viewConstraints.viewId) && !lodash_isstring_1.default(viewConstraints.viewId))) {
        return new TypeError('View ID must be a string');
    }
    return false;
}
/**
 * An adapter for Slack's interactive message components such as buttons, menus, and dialogs.
 * @typicalname slackInteractions
 */
var SlackMessageAdapter = /** @class */ (function () {
    /**
     * Create a message adapter.
     *
     * @param signingSecret - Slack app signing secret used to authenticate request
     * @param options.syncResponseTimeout - number of milliseconds to wait before flushing a synchronous response to an
     *   incoming request and falling back to an asynchronous response.
     * @param options.lateResponseFallbackEnabled - whether or not promises that resolve after the syncResponseTimeout can
     *   fallback to a request for the response_url. this only works in cases where the semantic meaning of the response
     *   and the response_url are the same.
     */
    function SlackMessageAdapter(signingSecret, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.syncResponseTimeout, syncResponseTimeout = _c === void 0 ? 2500 : _c, _d = _b.lateResponseFallbackEnabled, lateResponseFallbackEnabled = _d === void 0 ? true : _d;
        if (!lodash_isstring_1.default(signingSecret)) {
            throw new TypeError('SlackMessageAdapter needs a signing secret');
        }
        if (syncResponseTimeout > 3000 || syncResponseTimeout < 1) {
            throw new TypeError('syncResponseTimeout must be between 1 and 3000');
        }
        this.signingSecret = signingSecret;
        this.syncResponseTimeout = syncResponseTimeout;
        this.lateResponseFallbackEnabled = lateResponseFallbackEnabled;
        this.callbacks = [];
        this.axios = axios_1.default.create({
            headers: {
                'User-Agent': util_1.packageIdentifier(),
            },
        });
        debug('instantiated');
    }
    /* Interface for using the built-in server */
    /**
     * Create a server that dispatches Slack's interactive message actions and menu requests to this message adapter
     * instance. Use this method if your application will handle starting the server.
     *
     * @returns A promise that resolves to an instance of http.Server and will dispatch interactive message actions and
     *   options requests to this message adapter instance. See
     *   https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_server
     */
    SlackMessageAdapter.prototype.createServer = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: more options (like https)
                return [2 /*return*/, http_1.default.createServer(this.requestListener())];
            });
        });
    };
    /**
     * Start a built-in server that dispatches Slack's interactive message actions and menu requests to this message
     * adapter interface.
     *
     * @returns A promise that resolves once the server is ready
     */
    SlackMessageAdapter.prototype.start = function (port) {
        var _this = this;
        return this.createServer()
            .then(function (server) { return new Promise(function (resolve, reject) {
            _this.server = server;
            server.on('error', reject);
            server.listen(port, function () { return resolve(server); });
            debug('server started - port: %s', port);
        }); });
    };
    /**
     * Stop the previously started built-in server.
     *
     * @returns A promise that resolves once the server is cleaned up.
     */
    SlackMessageAdapter.prototype.stop = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!util_1.isFalsy(_this.server)) {
                _this.server.close(function (error) {
                    delete _this.server;
                    if (!util_1.isFalsy(error)) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            }
            else {
                reject(new Error('SlackMessageAdapter cannot stop when it did not start a server'));
            }
        });
    };
    /* Interface for bringing your own server */
    /**
     * Create a middleware function that can be used to integrate with the `express` web framework in order for incoming
     * requests to be dispatched to this message adapter instance.
     *
     * @returns A middleware function (see http://expressjs.com/en/guide/using-middleware.html)
     */
    SlackMessageAdapter.prototype.expressMiddleware = function () {
        var requestListener = this.requestListener();
        return function (req, res, _next) {
            requestListener(req, res);
        };
    };
    /**
     * Create a request listener function that handles HTTP requests, verifies requests and dispatches responses
     */
    SlackMessageAdapter.prototype.requestListener = function () {
        return http_handler_1.createHTTPHandler(this);
    };
    /* Interface for adding handlers */
    /* tslint:disable max-line-length */
    /**
     * Add a handler for an interactive message action.
     *
     * Usually there's no need to be concerned with _how_ a message is sent to Slack, but the following table describes it
     * fully.
     *
     * **Action**|**Return `object`**|**Return `Promise<object>`**|**Return `undefined`**|**Call `respond(message)`**|**Notes**
     * :-----:|:-----:|:-----:|:-----:|:-----:|:-----:
     * **Button Press**| Message in response | When resolved before `syncResponseTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` | Create a new message instead of replacing using `replace_original: false`
     * **Menu Selection**| Message in response | When resolved before `syncResponseTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` | Create a new message instead of replacing using `replace_original: false`
     * **Message Action** | Message in response | When resolved before `syncResponseTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` |
     * **Dialog Submission**| Error list in response | Error list in response | Empty response | Message in request to `response_url` | Returning a Promise that takes longer than 3 seconds to resolve can result in the user seeing an error. Warning logged if a promise isn't completed before `syncResponseTimeout`.
     *
     * @param matchingConstraints - the callback ID (as a string or RegExp) or an object describing the constraints to
     *   match actions for the handler.
     * @param callback - the function to run when an action is matched
     * @returns this instance (for chaining)
     */
    /* tslint:enable max-line-length */
    SlackMessageAdapter.prototype.action = function (matchingConstraints, callback) {
        var actionConstraints = formatMatchingConstraints(matchingConstraints);
        var error = validateConstraints(actionConstraints);
        if (error) {
            debug('action could not be registered: %s', error.message);
            throw error;
        }
        var storableConstraints = Object.assign(actionConstraints, {
            handlerType: "action" /* Action */,
        });
        return this.registerCallback(storableConstraints, callback);
    };
    /* tslint:disable max-line-length */
    /**
     * Add a handler for an options request
     *
     * Usually there's no need to be concerned with _how_ a message is sent to Slack, but the
     * following table describes it fully
     *
     * &nbsp;|**Return `options`**|**Return `Promise<options>`**|**Return `undefined`**|**Notes**
     * :-----:|:-----:|:-----:|:-----:|:-----:
     * **Options Request**| Options in response | Options in response | Empty response | Returning a Promise that takes longer than 3 seconds to resolve can result in the user seeing an error. If the request is from within a dialog, the `text` field is called `label`.
     *
     * @param matchingConstraints - the callback ID (as a string or RegExp) or an object describing the constraints to
     *   select options requests for the handler.
     * @param callback - the function to run when an options request is matched
     * @returns this instance (for chaining)
     */
    /* tslint:enable max-line-length */
    SlackMessageAdapter.prototype.options = function (matchingConstraints, callback) {
        var optionsConstraints = formatMatchingConstraints(matchingConstraints);
        var error = validateConstraints(optionsConstraints) ||
            validateOptionsConstraints(optionsConstraints);
        if (error) {
            debug('options could not be registered: %s', error.message);
            throw error;
        }
        var storableConstraints = Object.assign(optionsConstraints, {
            handlerType: "options" /* Options */,
        });
        return this.registerCallback(storableConstraints, callback);
    };
    /**
     * Add a handler for view submission.
     *
     * The value returned from the `callback` determines the response sent back to Slack. The handler can return a plain
     * object with a `response_action` property to dismiss the modal, push a view into the modal, display validation
     * errors, or update the view. Alternatively, the handler can return a Promise for this kind of object, which resolves
     * before `syncResponseTimeout` or `lateResponseFallbackEnabled: false`, to perform the same response actions. If the
     * Promise resolves afterwards or `lateResponseFallbackEnabled: true` then the modal will be dismissed. If the handler
     * returns `undefined` the modal will be dismissed.
     *
     * @param matchingConstraints - the callback ID (as a string or RegExp) or an object describing the constraints to
     *   match view submissions for the handler.
     * @param callback - the function to run when an view submission is matched
     * @returns this instance (for chaining)
     */
    SlackMessageAdapter.prototype.viewSubmission = function (matchingConstraints, callback) {
        var viewConstraints = formatMatchingConstraints(matchingConstraints);
        var error = validateConstraints(viewConstraints) || validateViewConstraints(viewConstraints);
        if (error) {
            debug('view submission could not be registered: %s', error.message);
            throw error;
        }
        var storableConstraints = Object.assign(viewConstraints, {
            handlerType: "view_submission" /* ViewSubmission */,
        });
        return this.registerCallback(storableConstraints, callback);
    };
    /**
     * Add a handler for view closed interaction. The handler should not return a value.
     *
     * @param matchingConstraints - the callback ID (as a string or RegExp) or an object describing the constraints to
     *   match view closed interactions for the handler.
     * @param callback - the function to run when an view closed interaction is matched
     * @returns this instance (for chaining)
     */
    SlackMessageAdapter.prototype.viewClosed = function (matchingConstraints, callback) {
        var viewConstraints = formatMatchingConstraints(matchingConstraints);
        var error = validateConstraints(viewConstraints) || validateViewConstraints(viewConstraints);
        if (error) {
            debug('view closed could not be registered: %s', error.message);
            throw error;
        }
        var storableConstraints = Object.assign(viewConstraints, {
            handlerType: "view_closed" /* ViewClosed */,
        });
        return this.registerCallback(storableConstraints, callback);
    };
    /* Interface for HTTP servers (like express middleware) */
    /**
     * Dispatches the contents of an HTTP request to the registered handlers.
     *
     * @remarks
     * This is an internal API not meant to be used by code depending on this package.
     *
     * @internal
     * @returns A promise of the response information (an object with status and content that is a JSON serializable
     *   object or a string or undefined) for the request. An undefined return value indicates that the request was not
     *   matched.
     */
    SlackMessageAdapter.prototype.dispatch = function (payload) {
        var _this = this;
        var callback = this.matchCallback(payload);
        if (util_1.isFalsy(callback)) {
            debug('dispatch could not find a handler');
            debug({ payload: payload });
            return undefined;
        }
        debug('dispatching to handler');
        var callbackFn = callback[1];
        // when a response_url is present,`respond()` function created to to send a message using it
        var respond = payload.response_url ? function (message) {
            if (typeof message.then === 'function') {
                throw new TypeError('Cannot use a Promise as the parameter for respond()');
            }
            debug('sending async response');
            return _this.axios.post(payload.response_url, message);
        } : undefined;
        var callbackResult;
        try {
            callbackResult = callbackFn.call(this, payload, respond);
        }
        catch (error) {
            debug('callback error: %o', error);
            return Promise.resolve({ status: ResponseStatus.Failure });
        }
        if (!util_1.isFalsy(callbackResult)) {
            return util_1.promiseTimeout(this.syncResponseTimeout, callbackResult)
                .then(function (content) { return ({ content: content, status: ResponseStatus.Ok }); })
                .catch(function (error) {
                if (error.code === errors_1.ErrorCode.PromiseTimeout) {
                    // warn and continue for promises that cannot be saved with a later async response.
                    // this includes dialog submissions because the response_url doesn't have the same
                    // semantics as the response, any request that doesn't contain a response_url, and
                    // if this has been explicitly disabled in the configuration.
                    if (!_this.lateResponseFallbackEnabled || respond === undefined || payload.type === 'dialog_submission') {
                        debug('WARNING: The response Promise did not resolve under the timeout.');
                        return callbackResult
                            .then(function (content) { return ({ content: content, status: ResponseStatus.Ok }); })
                            .catch(function () { return ({ status: ResponseStatus.Failure }); });
                    }
                    // save a late promise by sending an empty body in the response, and then use the
                    // response_url to send the eventually resolved value
                    callbackResult.then(respond).catch(function (callbackError) {
                        // when the promise is late and fails, we cannot do anything but log it
                        debug('ERROR: Promise was late and failed. Use `.catch()` to handle errors.');
                        throw callbackError;
                    });
                    return { status: ResponseStatus.Ok };
                }
                return { status: ResponseStatus.Failure };
            });
        }
        // The following result value represents:
        // * "no replacement" for message actions
        // * "submission is valid" for dialog submissions and view submissions
        // * "no suggestions" for menu options TODO: check that this is true
        // * "ack" for view closed
        return Promise.resolve({ status: 200 });
    };
    SlackMessageAdapter.prototype.registerCallback = function (constraints, callback) {
        // Validation
        if (!lodash_isfunction_1.default(callback)) {
            debug('did not register callback because its not a function');
            throw new TypeError('callback must be a function');
        }
        this.callbacks.push([constraints, callback]);
        return this;
    };
    SlackMessageAdapter.prototype.matchCallback = function (payload) {
        return this.callbacks.find(function (_a) {
            var constraints = _a[0];
            // if the callback ID constraint is specified, only continue if it matches
            if (!util_1.isFalsy(constraints.callbackId)) {
                // The callback ID is located at a different path in the payload for view submission and view closed
                // than for actions
                var callbackId = ((constraints.handlerType === "view_submission" /* ViewSubmission */ ||
                    constraints.handlerType === "view_closed" /* ViewClosed */) && payload.view) ? payload.view.callback_id : payload.callback_id;
                if (lodash_isstring_1.default(constraints.callbackId) && callbackId !== constraints.callbackId) {
                    return false;
                }
                if (lodash_isregexp_1.default(constraints.callbackId) && !constraints.callbackId.test(callbackId)) {
                    return false;
                }
            }
            // if the action constraint is specified, only continue if it matches
            if (constraints.handlerType === "action" /* Action */) {
                // a payload that represents an action either has actions, submission, or message defined
                if (!(payload.actions || payload.submission || payload.message)) {
                    return false;
                }
                // dialog submissions don't have an action defined, so an empty action is substituted for
                // the purpose of callback matching
                var action = payload.actions ? payload.actions[0] : {};
                // if the block ID constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.blockId)) {
                    if (lodash_isstring_1.default(constraints.blockId) && action.block_id !== constraints.blockId) {
                        return false;
                    }
                    if (lodash_isregexp_1.default(constraints.blockId) && !constraints.blockId.test(action.block_id)) {
                        return false;
                    }
                }
                // if the action ID constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.actionId)) {
                    if (lodash_isstring_1.default(constraints.actionId) && action.action_id !== constraints.actionId) {
                        return false;
                    }
                    if (lodash_isregexp_1.default(constraints.actionId) && !constraints.actionId.test(action.action_id)) {
                        return false;
                    }
                }
                // button and message actions have a type defined inside the action, dialog submission
                // actions have a type defined at the top level, and select actions don't have a type
                // defined, but type can be inferred by checking if a `selected_options` property exists in
                // the action.
                // tslint:disable-next-line strict-boolean-expressions
                var type = action.type || payload.type || (action.selected_options && 'select');
                if (!type) {
                    debug('no type found in dispatched action');
                }
                // if the type constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.type) && constraints.type !== type) {
                    return false;
                }
                // if the unfurl constraint is specified, only continue if it matches
                if ('unfurl' in constraints &&
                    ((constraints.unfurl && !payload.is_app_unfurl) ||
                        (!constraints.unfurl && payload.is_app_unfurl))) {
                    return false;
                }
            }
            if (constraints.handlerType === "options" /* Options */) {
                // a payload that represents an options request in attachments always has a name defined
                // at the top level. in blocks the type is block_suggestion and has no name
                if (!('name' in payload || (payload.type && payload.type === 'block_suggestion'))) {
                    return false;
                }
                // if the block ID constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.blockId)) {
                    if (lodash_isstring_1.default(constraints.blockId) && payload.block_id !== constraints.blockId) {
                        return false;
                    }
                    if (lodash_isregexp_1.default(constraints.blockId) && !constraints.blockId.test(payload.block_id)) {
                        return false;
                    }
                }
                // if the action ID constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.actionId)) {
                    if (lodash_isstring_1.default(constraints.actionId) && payload.action_id !== constraints.actionId) {
                        return false;
                    }
                    if (lodash_isregexp_1.default(constraints.actionId) && !constraints.actionId.test(payload.action_id)) {
                        return false;
                    }
                }
                // an options request always has a type at the top level which can be one of three values
                // that need to be mapped into the values for the `within` constraint:
                // * type:interactive_message => within:interactive_message
                // * type:block_suggestion => within:block_actions
                // * type:dialog_suggestion => within:dialog
                if (!util_1.isFalsy(constraints.within)) {
                    if (constraints.within === 'interactive_message' && payload.type !== 'interactive_message') {
                        return false;
                    }
                    if (constraints.within === 'block_actions' && payload.type !== 'block_suggestion') {
                        return false;
                    }
                    if (constraints.within === 'dialog' && payload.type !== 'dialog_suggestion') {
                        return false;
                    }
                }
            }
            if (constraints.handlerType === "view_submission" /* ViewSubmission */ ||
                constraints.handlerType === "view_closed" /* ViewClosed */) {
                // a payload that represents a view submission always has a type property set to view_submission,
                // a payload that represents a view closed interaction always has a type property set to view_closed
                if (!util_1.isFalsy(payload.type) &&
                    (constraints.handlerType === "view_submission" /* ViewSubmission */ && payload.type !== 'view_submission') ||
                    (constraints.handlerType === "view_closed" /* ViewClosed */ && payload.type !== 'view_closed')) {
                    return false;
                }
                // if there's no view in this payload, this payload is malformed - abort matching.
                if (util_1.isFalsy(payload.view)) {
                    return false;
                }
                // if the view ID constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.viewId) && payload.view.id !== constraints.viewId) {
                    return false;
                }
                // if the external ID constraint is specified, only continue if it matches
                if (!util_1.isFalsy(constraints.externalId)) {
                    if (lodash_isstring_1.default(constraints.externalId) && payload.view.external_id !== constraints.externalId) {
                        return false;
                    }
                    if (lodash_isregexp_1.default(constraints.externalId) && !constraints.externalId.test(payload.view.external_id)) {
                        return false;
                    }
                }
            }
            // if there's no reason to eliminate this callback, then its a match!
            return true;
        });
    };
    return SlackMessageAdapter;
}());
exports.SlackMessageAdapter = SlackMessageAdapter;
exports.default = SlackMessageAdapter;
/** Some HTTP response statuses. */
var ResponseStatus;
(function (ResponseStatus) {
    ResponseStatus[ResponseStatus["Ok"] = 200] = "Ok";
    ResponseStatus[ResponseStatus["Failure"] = 500] = "Failure";
})(ResponseStatus || (ResponseStatus = {}));
function hasBlockRelatedConstraints(constraints) {
    var asBlockRelatedConstraints = constraints;
    return !(util_1.isFalsy(asBlockRelatedConstraints.blockId) && util_1.isFalsy(asBlockRelatedConstraints.actionId));
}
//# sourceMappingURL=adapter.js.map